% function cartesianDetections = bistatDisambiguation(det,rangeErr)
% this is based on "Two Methods for Target Localization in Multistatic
% Passive Radar" by MATEUSZ MALANOWSKI and KRZYSZTOF KULPA

load det

% maxN = 1e6; % max number of combinatorics considered 
% maxTime = 1; % [s] maximum time allowed for processing

% det2 = det; % make a copy to remove from as things are found 
nE = length(det);
nPerEmit = zeros(nE,1);
for i = 1:nE
  nPerEmit(i) = size(det(i).rrd,1);
end

%% create combinations 
comboIdx = nchoosek(1:nE,4); % choose 4 emitters
r = []; % measured bistatic range matrix 
S = []; % emitter position matrix
d = []; % doppler matrix
bigidx = []; % stores emitter number and detection id for that emitter
for i = 1:size(comboIdx,1)
  IDs = comboIdx(i,:);
  sizes = nPerEmit(IDs);
  [X,Y,Z,W] = ndgrid(1:sizes(1),1:sizes(2),1:sizes(3),1:sizes(4));
  n = numel(X);
  rtmp = zeros(4,1,n,'single','gpuArray');
  dtmp = rtmp;
  XYZW = [X(:),Y(:),Z(:),W(:)];
  sPre = zeros(4,3,1,'single','gpuArray');
  for j = 1:4
    rtmp(j,:,:) = permute(det(IDs(j)).rrd(XYZW(:,j),1),[2,3,1]);
    dtmp(j,:,:) = permute(det(IDs(j)).rrd(XYZW(:,j),2),[2,3,1]);
    sPre(j,:) = det(IDs(j)).s;
  end
  stmp = repmat(sPre,[1,1,n]);
  r = cat(3,r,rtmp);
  d = cat(3,d,dtmp);
  S = cat(3,S,stmp);
  idxtmp = cat(2,permute(XYZW,[2,3,1]),repmat(IDs',[1,1,n]));
  bigidx = cat(3,bigidx,idxtmp);
end

% S is 4x3xN
% r is 4x1xN

% return

%% evaluate position for all combinations

z = sum([S.*S,-r.*r],2)/2;

Sp = permute(S,[2,1,3]);
S2 = mm3d(Sp,S);
s2i = pagefun(@inv,S2);
Sst = mm3d(s2i,Sp); % s star

a = mm3d(Sst,z);
b = mm3d(Sst,r);
ap = permute(a,[2,1,3]);
bp = permute(b,[2,1,3]);

btb1 = (mm3d(bp,b)-1);
determinant = 4*mm3d(ap,b).^2 - 4*btb1.*mm3d(ap,a);
idx = permute(determinant,[3,1,2]) >= 0; 
% apparently setting the determinant = 0 for complex cases can still yield
% useful results according to the paper, have not analyzed further
part1 = -2*mm3d(ap(:,:,idx),b(:,:,idx));
sqrtDet = sqrt(determinant(:,:,idx));
RtHat = (part1 + sqrtDet)./(2*btb1(:,:,idx));
RtHat2 = (part1 - sqrtDet)./(2*btb1(:,:,idx));
RtHat(RtHat<0) = RtHat2(RtHat<0);
% ^ this is the "spherical interpolation" method, which has been observed
% to be significantly more accurate

xyz = a(:,:,idx) + b(:,:,idx).*RtHat;

%% compare result to known measurement accuracy
XYZ = permute(xyz,[2,1,3]);
XYZvel = getVel(XYZ,S(:,:,idx),d(:,:,idx)); 


y = Hbistat(XYZ,XYZvel,S(:,:,idx)); % gets what we should have measured 

posErr = (r(:,:,idx) - y(:,1,:))/rangeErr;
velErr = (d(:,:,idx) - y(:,2,:))/dopErr;
subIdx = permute(sum(posErr.^2),[3,1,2]) < 20*4;
% subIdx = permute(sum(posErr.^2 + velErr.^2),[3,1,2]) < 40*4;

sum(subIdx)


y0 = y(:,:,subIdx);

hold off
plot(txyz(:,1),txyz(:,2),'+')
hold on
plot(squeeze(XYZ(1,1,subIdx)),squeeze(XYZ(1,2,subIdx)),'o')

hold off
plot(vxyz(:,1),vxyz(:,2),'+')
hold on
plot(squeeze(XYZvel(1,1,subIdx)),squeeze(XYZvel(1,2,subIdx)),'o')



return
err = r(:,:,idx) - sqrt(sum((XYZ-S(:,:,idx)).^2,2)) - sqrt(sum(XYZ.^2,2));
subIdx = permute(sum(err.^2),[3,1,2])<4*4*rangeErr^2;





subidxtmppre = bigidx(:,:,idx);
subidxtmp = subidxtmppre(:,:,subIdx);

% sum(subIdx)
cartesianDetections = permute(xyz(:,:,subIdx),[3,1,2]);





%% lastly, perform iterative solution for most accurate results















%% end of useful code

% for spherical intersection method of getting RtHat:
% m = size(S,1); % number of transmitters
% rp = permute(r,[2,1,3]);
% T = repmat(eye(m,'gpuArray'),[1,1,n]) - mm3d(S,Sst);
% rtt = mm3d(rp,T);
% RtHat = - mm3d(rtt,z)./mm3d(rtt,r); % SX method
